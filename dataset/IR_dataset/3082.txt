روش مشابهی با استفاده از برنامه‌سازی پویا برای حل مسئله کوله‌پشتی ۰ و ۱ با وجود دارد. مانند بالا، فرض کنید formula_47ها اعداد صحیح اکیداً مثبتی هستند. formula_56 را بیشترین ارزش قابل دستیابی، با استفاده از اشیای ۱ تا formula_57 با حداکثر وزن formula_36 تعریف کنید.

formula_56 را می‌توان به‌طور بازگشتی، مطابق زیر تعریف کرد:
* formula_60
* formula_61
* formula_62 اگر formula_63
* formula_64 اگر formula_65.

پاسخ با محاسبهٔ formula_66 بدست می‌آید. برای کارآمد شدن راه حل، می‌توان از جدولی برای نگهداری نتایج محاسبات قبلی استفاده کرد؛ بنابراین پیچیدگی زمانی آن formula_46 و حافظه formula_46 خواهد شد. همچنین می‌توان حجم حافظه را به formula_69 کاهش داد. به این ترتیب که آرایهٔ یک بعدیformula_35، ارزش بهینه تاکنون را نشان می‌دهد. از formula_71 شروع کرده، آرایه را پر می‌کنیم. سپس با حرکت بر روی formula_57، مقدار formula_35 را با افزدون یک شی جدید به انتخاب‌ها، به روز آوری می‌کنیم.

الگوریتم دیگری برای مسئله کوله‌پشتی ۰ و ۱ در سال ۱۹۷۴ ارائه شد که گاهی «رویارویی در میانه» نیز نامیده می‌شود. این الگوریتم نسبت به تعداد اشیا نمایی است. (این اسم، از الگوریتمی مشابه در رمزنگاری نشات گرفته‌است). هنگامی که formula_7 نسبت به formula_1 بسیار بزرگتر باشد (یعنیformula_7 از formula_77 هم بزرگتر باشد) این الگوریتم نسبت به روش پویا از نظر زمانی بهینه تر است. برای نمونه فرض کنید formula_6ها نامنفی باشند اما صحیح نباشند. در اینجا نیز می‌توان از روش پویا استفاده کرد: اگر عددها formula_79 رقم بعد از اعشار داشته باشند کافی است آن‌ها را در formula_80 ضرب و سپس رند کرد (با استفاده از محاسبات ممیز ثابت). روش پویا با این تغییرات، از مرتبهٔ زمانی formula_81 و حافظهٔ formula_82 خواهد بود.

الگوریتم «رویارویی در میانه» به صورت زیر است:
# مجموعهٔ formula_83 را به دو مجموعهٔ formula_84 و formula_85 با اندازهٔ نسبتاً برابر تقسیم کنید.
# ارزش‌ها و وزن‌های هر زیر مجموعه از هریک از formula_84 و formula_85 را بدست آورید.
# برای هر زیرمجموعه از formula_84، بهترین مکمل formula_85 را از زیر مجموعه‌هایش انتخاب کنید: به عبارتی زیر مجموعه‌ای از formula_85 با بیشترین جمع ارزش کالاها، به نحوی که جمع وزن‌های دو زیر مجموعه، از formula_91 بیشتر نشود. بیشترین ارزش بدست آمده را ذخیره کنید.

این الگوریتم از مرتبهٔ حافظهٔ formula_92 است و با پیاده‌سازی بهینه گام ۳، از مرتبهٔ زمانی formula_93 می‌شود. (برای نمونه با مرتب کردن زیرمجموعه‌های formula_94 بر حسب وزن، چشم پوشی از زیر مجموعه‌هایی از formula_94 که وزنی بیشتر از سایر زیر مجموعه‌ها با ارزش بزرگتر/مساوی دارند و استفاده از جستجوی دودویی برای یافتن بهترین تطابق). مانند روش رویارویی در میانه در رمز نگاری، استفاده از این الگوریتم با هزینه کردن حافظه (مرتبهٔ نمایی به جای مقدار ثابت) باعث بهینه شدن زمان اجرا می‌شود. می‌دانیم چنانچه بخواهیم همه زیر مجموعه‌های {۱...n} را به روش brute force بررسی کنیم، مرتبهٔ زمانی formula_96 خواهد شد اما با این الگوریتم آن را بهینه کردیم.